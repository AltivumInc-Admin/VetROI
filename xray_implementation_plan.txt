VetROI X-RAY IMPLEMENTATION PLAN
================================
Generated: June 19, 2025
Purpose: Strategic X-Ray instrumentation for VetROI components

===========================================
EXECUTIVE SUMMARY
===========================================

Current State:
- Basic X-Ray tracing enabled globally via SAM template
- API Gateway has tracing enabled
- Lambda functions have permissions but no deep instrumentation
- No service-level tracing (SDK calls not patched)
- Step Functions not traced

Implementation Time: ~2 hours total
ROI: Immediate visibility into $0.08/document DD214 costs and performance bottlenecks

===========================================
PHASE 1: INFRASTRUCTURE (30 minutes)
===========================================

1. Step Functions X-Ray Enablement
   - Add TracingConfiguration to VetROI-DD214-Processing
   - This will show the complete DD214 pipeline flow
   - See timing for each state (Textract, Macie, Comprehend)

2. Enhanced Lambda Permissions
   - Already have xray:PutTraceSegments permission
   - No additional IAM changes needed

===========================================
PHASE 2: LAMBDA INSTRUMENTATION (45 minutes)
===========================================

Priority 1 - DD214 Processing Pipeline:
--------------------------------------
1. VetROI_DD214_Parser (handler.py)
   - Add: from aws_xray_sdk.core import patch_all; patch_all()
   - Custom segments for:
     * Textract result processing time
     * AI enhancement with Bedrock
     * Document validation
   - Annotations: document_id, document_size, processing_step

2. VetROI_Macie_Handler (macie_handler.py)
   - Add: from aws_xray_sdk.core import patch_all; patch_all()
   - Custom segments for:
     * Macie job creation
     * PII finding processing
     * Redaction operations
   - Annotations: job_id, pii_found (true/false), redaction_time

3. VetROI_DD214_UploadTrigger (upload_trigger.py)
   - Add basic patching for S3 and Step Functions calls
   - Annotation: file_size

Priority 2 - Core Application:
-----------------------------
4. VetROI_Recommend (handler.py)
   - Add: from aws_xray_sdk.core import patch_all; patch_all()
   - CRITICAL: Custom segment for O*NET API calls:
     ```python
     from aws_xray_sdk.core import xray_recorder
     
     @xray_recorder.capture('onet_api_call')
     def call_onet_api(endpoint, params):
         xray_recorder.current_subsegment().put_metadata('endpoint', endpoint)
         # existing code
     ```
   - Annotations: military_code, careers_returned

5. VetROI_Sentra_Conversation (conversation_handler.py)
   - Add patching for Bedrock calls
   - Custom segment for AI inference time
   - Annotations: conversation_id, model_used, token_count

===========================================
PHASE 3: CUSTOM BUSINESS LOGIC (45 minutes)
===========================================

Key Segments to Add:

1. DD214 Processing Metrics:
   ```python
   @tracer.capture_method
   def process_dd214_document(document_id):
       tracer.put_annotation("document_id", document_id)
       tracer.put_annotation("processing_stage", "textract_complete")
       tracer.put_metadata("document_fields", extracted_fields)
   ```

2. Cost Tracking Integration:
   - Add cost estimates as X-Ray metadata
   - Track service usage for cost optimization
   ```python
   tracer.put_metadata("estimated_cost", {
       "textract": 0.045,
       "macie": 0.005,
       "total": 0.08
   })
   ```

3. Performance Monitoring:
   - O*NET API response times
   - Bedrock inference latency
   - Database query performance

===========================================
IMPLEMENTATION STEPS
===========================================

Step 1: Update SAM Template (10 min)
```yaml
DD214ProcessingStateMachine:
  Properties:
    TracingConfiguration:
      Enabled: true
```

Step 2: Update Lambda Layers (20 min)
- Ensure aws-xray-sdk is in shared layer
- Already present via aws-lambda-powertools

Step 3: Code Updates (60 min)
For each Lambda function:
1. Add imports at top:
   ```python
   from aws_xray_sdk.core import patch_all
   patch_all()
   ```

2. Add custom segments for business logic:
   ```python
   from aws_lambda_powertools import Tracer
   tracer = Tracer()
   
   @tracer.capture_method
   def process_operation():
       tracer.put_annotation("operation", "name")
   ```

Step 4: Deploy and Test (30 min)
```bash
cd /Users/christianperez/Desktop/VetROI
sam build
sam deploy --profile amplify-cli-user2
```

===========================================
EXPECTED OUTCOMES
===========================================

1. Service Map Visibility:
   - Complete DD214 processing flow
   - API Gateway → Lambda → Textract → Macie → Comprehend → Bedrock
   - O*NET API external calls
   - DynamoDB operations

2. Performance Insights:
   - Identify slowest operations (likely Textract at ~30s)
   - O*NET API response times
   - Bedrock inference latency
   - Cold start impact

3. Cost Optimization:
   - See exact duration for each service
   - Identify retry patterns
   - Find optimization opportunities

4. Error Tracking:
   - Failed Textract jobs
   - Macie scanning issues
   - API timeouts

===========================================
MINIMAL VIABLE IMPLEMENTATION (30 min)
===========================================

If time is limited, focus on:

1. Enable Step Functions tracing (5 min)
2. Add patch_all() to these 3 critical functions (15 min):
   - VetROI_DD214_Parser
   - VetROI_Recommend
   - VetROI_Macie_Handler
3. Add document_id annotation everywhere (10 min)

This gives 80% of the value in 30 minutes.

===========================================
MONITORING & ALERTS
===========================================

After implementation, set up:

1. X-Ray Service Map alerts for:
   - Response time > 10s
   - Error rate > 5%
   - Throttling on any service

2. Custom CloudWatch metrics from X-Ray:
   - DD214 processing time by stage
   - O*NET API latency
   - Cost per document processed

3. Weekly reports showing:
   - Processing time trends
   - Most expensive operations
   - Optimization opportunities